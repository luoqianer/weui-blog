---
layout: blog
title: 嵌入式硬件通信接口协议-SPI（三）模拟接口应用
date: 2019-02-03 21:40:48
categories: 嵌入式-ARM
tags: [SPI,单片机外设]
---

简单完成模拟SPI各个接口的实现后，仅仅利用示波器抓取信号的时序当然是不够的。

虽然单片机作为SPI主机输出数据时的信号很容易抓取，但是从机发出的数据（即主机读取MISO信号时序），还要找个SPI接口的外设器件，这样主机发出、从机反馈。比如SPI-FLASH，此处找来一片型号为W25Q16的FLASH，验证模拟SPI接口与FLASH器件的通信正确性。

要想熟练使用W25Q16，要多下功夫学习熟悉Spec；想精通SPI-FLASH，更要对JEDEC组织下的SFDP（Serial
Flash Discoverable
Parameters，串行闪存可发现参数）规范有个认识和了解。其官方链接地址：<https://www.jedec.org/standards-documents/docs/jesd216b>

国外网站，加载慢，这里提前给截个图贴一下：

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-SPI（三）模拟接口应用/8fed9ee87eef6344990751e20bb37aeb.png)

从W25Q16的手册可查阅各个接口，为了验证SPI的通信正确性，首先进行最简单读取JEDEC规范定义的芯片ID指令（0x9F）。

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-SPI（三）模拟接口应用/359115c4de921ab2b67339a940af6038.png)

根据JEDEC ID
(9Fh)指令的时序图，程序里利用编写好的SPI接口，发送指令并接收数据。利用这个指令可以判断编写的模拟SPI接口发送、接收数据的正确性。

看过上一篇《[嵌入式硬件通信接口协议-SPI（二）分层架构设计模拟接口](https://mp.weixin.qq.com/s/unh8SHE9wwGzFvwobIZjxA)》的读者，在此我对代码稍做个说明，相比于上一篇文章中提及的源码，此处对读取一个字节数据的函数接口做个修改：

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-SPI（三）模拟接口应用/3e5a96e46532792e9e64961cabbd3036.png)

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-SPI（三）模拟接口应用/6c94fdd192531b4d761c55fba0fdef7a.png)

修改后的思路是以参数的形式传入地址，把读出的数据存到该地址里，这样接口的返回值就可以用于表示接口的正确执行与否。

这么做，主要考虑在不同平台移植时，如果用硬件SPI接口，有些硬件SPI接口使用的过程，对寄存器使用while死循环的方式等待的，所以要考虑超时情况。因此有必要预留返回值作为函数执行的结果，而真正读取到的数据放在所传地址参数指向的空间里。

验证模拟SPI接口的正确性，通过读取SPI-FLASH芯片的厂商ID，校验读到的数据与手册是否一致。

FLASH功能模块属于模块库层，介于应用层和驱动层之间。因此对SPI-FLASH模块的源码封装成lib层。

创建源码dclib_spiflash.c和dclib_spiflash.h文件。

同样的也需要对该FLASH设计初始化，此时需要调用BSP层的模拟SPI接口初始化，设置与FLASH芯片匹配的SPI通信配置项：数据宽度、时钟极性（CPOL:）、时钟相位（CPHA）、数据bit位大小端选择。

完成SPI初始化，直接对FLASH器件发起通信。最简单的指令(0x9F)可以读取FLASH芯片的厂商ID。

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-SPI（三）模拟接口应用/7647fa77ff567b1d043dc428cc02ffa3.png)

把程序烧入单片机运行查看读取效果，初步验证通信的正确性。

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-SPI（三）模拟接口应用/24a7eccb13338d9435e295a0035c03a6.png)

对比手册中的描述，读取到的JEDEC ID与手册里的完全一直。

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-SPI（三）模拟接口应用/dd5d2cc4a0b0e25a01993b8dc41eb543.png)

至此，可确定使用GPIO模拟的SPI接口可进行正确通信。

更多关于SPI-FLASH的操作，可以用心阅读数据手册，需要参考实现的源码，可以从开源平台检索相关的源码来参考。
