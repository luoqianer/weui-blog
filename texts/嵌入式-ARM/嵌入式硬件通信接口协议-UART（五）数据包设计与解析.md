---
layout: blog
title: 嵌入式硬件通信接口协议-UART（五）数据包设计与解析
date: 2019-02-03 21:33:43
categories: 嵌入式-ARM
tags: [UART,串口,单片机外设]
---


上一节讲到起止式（Start-Stop-Type）帧结构协议，该协议利用帧头、长度、校验构建帧结构，基于帧结构能实现对数据包的可靠、准确传输。

应用层数据包设计思路
--------------------

回到工程本身，帧结构中的数据包才是应用程序最终需要解析使用的，且与具体的业务需求有关。

这篇文章将简单介绍，在数据包里如何设计应用层的交互指令，从而实现具体的业务需求。分享个思路，就当抛砖引玉了。

类似于帧结构，在设计数据包时，根据交互逻辑的具体需求，同样采用逐字节组成字段，字段组成数据包，从而完成指令交互。

具体到项目中，一般地有目标地址、源地址、指令类型、传输方向、级联序号、参数ID、参数值等等。

字段的定义因项目需求而定，以上提及的字段可能存在且不限于此。

以下介绍在具体项目中，对数据包设计与解析思路。**工程实践中方法众多，相信很多经验娴熟的老工程师肯定都有各自巧妙的编程思路，欢迎在本页留言交流。**

项目案例
--------



基于nRF51822的BLE终端设备，与上位机使用UART通信，物理线路使用USB转UART。

### 数据包定义：

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（五）数据包设计与解析/f98d4c9f3a87703eb33e406aca0338ea.png)

### 类型定义

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（五）数据包设计与解析/802b9091e6bb13e6b8f3e1560938e3a3.png)

### 参数名&参数值定义

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（五）数据包设计与解析/b434de993762bb07aad444de85714ad6.png)

根据以上定义，可以为应用程序设计指令解析的结构体，结构体中所定义的类型和参数名，使用枚举类型定义：

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（五）数据包设计与解析/346cf5ece14bbf27b293a8331bafd18b.png)

常规解析过程
------------

解析函数，一般地会把输入参数的
\*indata，利用一个新的结构体指针指向该输入参数，之后的解析使用结构体指针来对数据处理，增强代码可读性！

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（五）数据包设计与解析/b8e250f34a54f9a94c080bfe2fbd7fed.png)

上述截图中的定义方式出现了警告，这里需要做个如下的强制转换：

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（五）数据包设计与解析/87b612760e9e69c76544cb5d27dfd923.png)

常规的判断处理，多采用**switch(){case
:}**联合**if(...){;}else(...){;}**判断逻辑，这个模式的判断处理架构如下

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（五）数据包设计与解析/f59dfba28ed268a8b884a725f1b3941c.png)

**以上的做法，依次去判断类型、参数名，然后直接处理。当这两个字段的枚举成员数量少，倒还可以这么判断；但是如果工程需要扩展、业务有了新的需求，那么if(...){;}else(...){;}的逐一判断将会使得解析函数里的代码量巨大！**

**总结有以下几个缺点：**

1.  **业务需求有多少个类型或者其他分支，就需要多少个这样的判断逻辑，对于编写代码变成个体力活；**

2.  **在代码查看、维护时，面对的还是罗列了一大堆的switch(){case
    :}和if(...){;}else(...){;}语句；**

3.  **增删功能时，需要找到代码中具体的判断位置，然后小心翼翼给注释或者修改掉。**

这里已经没有任何的技术含量，基本上就是复制粘贴判断语句、修改判断对象，说到底也就是个查表的过程！

构建查表方式解析
----------------

既然要查表，当然是有个while()循环，然后递增某一变量来查表的过程。在这里，数据包结构体中定义的类型、参数名，都可以作为查表的对象，该如何选择？

假设：

1.  以类型作为查表对象，假如查表后类型等于查询参数，那么**参数名仍然是个多个分支的情况，要么继续查表要么继续采用switch(){case
    :}或者if(...){;}else(...){;}来判断众多不同的参数名；**

2.  以参数名作为查表对象，假如查表后参数名等于设备运行状态，那么**类型需要做最多三种判断：查询、设置、其他。**

对比以上两种，必然是第2个更能提高编程效率、缕清逻辑框架。

要查表就要建表，建表的结构体，以参数名作为被查对象，并且以回调函数的形式执行查表结果。建表如下：

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（五）数据包设计与解析/173470d8a5710677f7ccf45d46743a32.png)

**说是建表，其实就是定义一个结构体数组，数组的每个元素都是结构体类型，这里的结构体，主要由数据包协议的参数名和回调函数组成，定义如下：**

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（五）数据包设计与解析/3912c9b198f1387e54a25739e991309d.png)

在执行数据包解析的时候，查表的思路是：

1.  **先创建一个表结构的指针\*ptable指向表的开始位置，也就是指向数组内第一个元素{ECHO,
    dcapp_dev_echo}**

2.  **再创建一个数据包结构的指针\*pbuf指向输入数据首地址**

3.  **通过递增ptable指针，对ptable与pbuf的参数名成员进行比对**

4.  **最后执行ptable指针对应回调函数**

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（五）数据包设计与解析/f0d42e0e167b7fb2f6c75fd1f6d40059.png)

以上的思路，放到代码中，仅仅数行就可以实现对输入数据包参数名的解析！高效、清晰！

另外，建表时，把无效参数名对应的值和对应的回调函数放在最后，这样做的好处是查完整个表，无需区分是否找到对应的参数名，而直接执行指针对应的回调函数即可。

这样即使是未找到参数名，也会执行表中最后一个元素，就是错误解析的回调函数dcapp_parser_err()。

有了这样一个查表的处理方式，增删指令功能就变得简单太多了！增加功能，只需要在表中添加参数名和对应的回调函数，删除某功能，也是回到表中找到对应的参数名和回调函数即可！

总结一下，虽然查表方式非常清晰，但是对应的回调函数内部，需要独自处理和实现，并且每个参数名都需要单独处理。相比于采用switch(){case
:}联合if(...){;}else(...){;}判断逻辑，确实清晰很多。

以上的查表思路，来源于经历的项目，同时还参考了《STM32CubeExpansion_MEMSMIC1_V1.1》这个ST官方的数字麦克风开源项目示例，作为USB音频设备时，类似的回调函数方式：

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（五）数据包设计与解析/3756d90a2bfc3bfed38ad78b5519c107.png)

调试截图

解析到正确的数据包指令或者参数名之后，对应的函数执行结果是打印输出调试信息如下：

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（五）数据包设计与解析/21c5cee731e1b8e674da4a1044c8cb2e.png)

以上是初步的解析效果，可以通过回调函数，正确地跳转到对应的函数执行。

参考资料：

《X-CUBE-MEMSMIC1》\@ <http://www.stmcu.org.cn/document/detail/index/id-216480>
