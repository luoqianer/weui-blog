---
title: 嵌入式硬件通信接口协议-UART（三）快速使用串口及应用层设计
date: 2018-11-18 09:51:39
categories: 嵌入式-ARM
tags: [UART,串口,单片机外设]
---

串口启用流程
============

开讲前，先找几款芯片的串口demo程序瞄一眼。

依次有STM32的V3.5标准库、nRF52832的官方demo以及51核的STC15系列单片机的官方DEMO。


![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（三）快速使用串口及应用层设计/8df1f94623b28f31d2f7ab23c49b8b5b.png)

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（三）快速使用串口及应用层设计/69d661e72c8669157c0ebebc5ee2ed73.png)

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（三）快速使用串口及应用层设计/391d82c281069a8b6e382453b881652e.png)

从以上的部分demo例程来看，并结文章《[嵌入式硬件通信接口协议-UART（一）协议基础](https://mp.weixin.qq.com/s/Qmk0VEsPzlwYGhum42GdCQ)》的介绍，在启用串口的时候，需要配置的那几个参数有波特率、数据位、校验位、停止位等，从demo的源码中也是能够体现出来的。

而略有不同的是，在引脚配置灵活的ARM中，需要针对引脚进行配置。

验证输入输出
============

完成了串口的初始化，即可对输入输出进行操作，来验证串口是否可以正常的发送和接收数据。

一般的，最直接的方式就是向输出寄存器写入数据，就可以让芯片去完成UART信号输出到对应的引脚上。

如下图依次有STM32的V3.5**标准库**、**nRF52832的官方demo**以及**51核的STC15系列单片机的官方DEMO**。

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（三）快速使用串口及应用层设计/55ff336dfcd963aa97cf37228f40e465.png)

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（三）快速使用串口及应用层设计/2f1b23196562ae19042ec1c92b18d9bb.png)

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（三）快速使用串口及应用层设计/900a24a15036d67d26c2838ba3f1dd6d.png)

验证串口的输出，即在串口初始化成功后，对串口的输出寄存器写入数据，而芯片引脚则使用USB转TTL模块连接，USB端插入计算机的USB口，利用计算机的串口助手软件实现对数据的收发。

调试-输出
=========

开发调试过程中，输出的内容基本上就是想查看的变量值、代码的执行位置跟踪、算法或者某些运算的结果等等。这些输出，仅用于调试阶段，而在人机调试过程中，使用计算机的串口助手软件进行交互，则输出的数据应该便于识读和判断。

C库函数printf格式输出重定向到串口输出
-------------------------------------

输出串口数据过程中，需要向寄存器逐字节传入数据的，而在传送之前必不可少的，就是将要发送的数据、字符放到同一个Buffer后，执行轮询的方式传送直到buffer内容全部被传送。

而这个“放”的过程也是需要做些计算、判断，尤其是增加必要的字符来描述输出信息，保证信息的可识读。

在C标准库printf函数就有格式输出的功能，利用这个接口更便于调试输出这个过程。

这就需要将printf函数重定向到串口输出上！实现重定向只需3步：

1.  Options for target选项卡内勾选Use MicroLIB

2.  在串口实现的\*.c文件内，将stdio.h文件和stdarg.h文件包含进来

3.  重新定义int fputc函数的内部实现

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（三）快速使用串口及应用层设计/298bc37dce61a5b5ef96f86259e8d086.png)

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（三）快速使用串口及应用层设计/7f54199c89a65bf4e16b3404281c1502.png)

完成以上3步，即可利用printf函数来格式化输出，并且能够在串口上接收到。

ANSI C标准中有几个标准预定义宏：
--------------------------------

\__LINE__：源代码中的行号（字符串形式）

\__FILE__：当前\*.c源码文件的文件名（字符串形式）

\__DATE__：编译日期（字符串形式）

\__TIME__：编译时间（字符串形式）

\__STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1；

\__cplusplus：当编写C++程序时该标识符被定义。

有了上一步实现printf函数的重定向到串口后，基本就可以完美使用串口进行调试程序。

调试过程中可利用ANSI
C标准中的内置宏，比如__LINE__可以很方便跟踪代码执行到哪一行。

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（三）快速使用串口及应用层设计/15f7df7416b538e53c90ac627ea6e747.png)

调试-输入
=========

串口的接收，有轮询、中断、DMA等方式。

轮询方式，特点是消耗芯片资源，否则容易丢数据；

中断方式，特点是响应快、资源占用低；

DMA方式，各个芯片的配置不同而无法每款芯片都有该功能，所以代码兼容性可移植性较差。

一般地，对输入的数据进行分析判断时，如果是轮询的方式，则直接在收到后即判断；中断和DMA方式，都可以考虑存到buffer后再分析处理。

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（三）快速使用串口及应用层设计/66d86351dfaa332b1203f4cdd75e2ad8.png)

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（三）快速使用串口及应用层设计/797f57fb76556419eb5e146f257bb05d.png)

初见数据协议解析
================

如果是简单几个字符的指令，可以用上述那样简单判断，但是在稍微中等级别的工程项目中，用那样的方式都已经很不便于处理和扩展了。

比如有一串数据，并且长度不确定，将会超过10个字节、20个字节、100个字节甚至更多，那么这时候就必须使用协议解析的方式。

通常的，数据协议都会有协议头、长度、校验、数据内容等部分组成，数据将以包的形式进行收发，这时候使用解析的方式，对数据包进行解析。

这就是广泛使用的“起始式协议”。

实际的产品中有IC/ID读卡器模块的接口协议：

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（三）快速使用串口及应用层设计/b77fa6e574297f79bdbeb79559f624a4.png)

也有使用在PM2.5传感器上的：

![](/img/blog_pic/【硬件电路】嵌入式硬件通信接口协议-UART（三）快速使用串口及应用层设计/a5a015052d2f630d10f6428f4bd167ce.png)

这些都属于开发的模块产品，对外使用串口通信，并且数据协议采样了“起始式”的帧结构模式。


![](https://digcore.gitee.io/media/DigCore_Blog_Follow.png)
